#!/usr/bin/env Rscript

# functions to convert df of genotypic data to other formats
# the df has rows as individuals and columns as genotypes
# the each genotype is in two columns, i.e. one column per allele
# columns can be named
# the first column of the df contains sample names


################################
#' @title df2arlequin
#' @description converts df format data to Arlequin infile
#' @description modified vcf2arlequin function (vcf2others package)
#' @author Tomas Hrbek July 2021
#'
#' @param df -> df object (individuals as rows, two columns per genotype)
#' @param ind_pop -> population assignment of individuals in df (factor)
#' @param keep_pop -> population(s) of interest to include in Arlequin infile (fator)
#' @param inc_missing -> include missing data (logical)
#' @param out_file -> name of file to output (Arlequin infile)
#' @export Arlequin infile of microsatellites
#' @return nothing
#'
#' @details
#' This function converts df object to an Arlequin formatted input file
#' The function will optionally remove loci with missing data
#'
#' @example
#' df2arlequin(df = my_df, ind_pop = indiv_pop, keep_pop = pop_groups, inc_missing = TRUE, out_file = "Arlequin_infile.arp")
#' df2arlequin(my_df, indiv_pop, pop_groups, out_file = "Arlequin_infile.arp")
#'

df2arlequin <- function(df, ind_pop, keep_pop, inc_missing = TRUE, out_file = "arlequin.arp") {
  if (class(df) != "data.frame") {
    stop(paste("Expecting an object of class data.frame, received a", 
               class(df), "instead"))
  }
  if (class(ind_pop) != "factor" | class(keep_pop) != "factor") {
    stop(paste("Expecting population vector, received a", 
               class(ind_pop), "and", class(keep_pop), "instead"))
  }
  if (inc_missing == FALSE) {
    df <- df[!rowSums(is.na(df)), ]
  }
  df_list <- lapply(keep_pop, function(x) {
    df[x == ind_pop, ]
  })
  names(df_list) <- keep_pop
  pop_list <- vector(mode = "list", length = length(df_list))
  names(pop_list) <- names(df_list)
  
  for (i in 1:length(df_list)) {
    gt <- df_list[[i]]
    gt1 <- gt[,-1]
    gt1[is.na(gt1)] <- '?'
    allele1 <- gt1[,c(TRUE, FALSE)]
    rownames(allele1) <- paste(gt[,1], "_1", sep = "")
    allele2 <- gt1[,c(FALSE, TRUE)]
    rownames(allele2) <- paste(gt[,1], "_2", sep = "")
    
    pop_list[[i]][[1]] <- allele1
    pop_list[[i]][[2]] <- allele2
  }
  
  write("[Profile]", file = out_file)
  write("", file = out_file, append = TRUE)
  write("Title = 'Generated by df2arlequin.R'", file = out_file, append = TRUE)
  write(paste("NbSamples = ", length(df_list), sep = ""), file = out_file, append = TRUE)
  write("GenotypicData = 1", file = out_file, append = TRUE)
  write("LocusSeparator = WHITESPACE", file = out_file, append = TRUE)
  write("GameticPhase = 0", file = out_file, append = TRUE)
  write("MissingData = '?'", file = out_file, append = TRUE)
  write("DataType = MICROSAT", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write("[Data]", file = out_file, append = TRUE)
  write("[[Samples]]", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write(paste("#There are ", ncol(pop_list[[i]][[1]]), " Microsatellites", sep = ""), file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  
  for (i in 1:length(pop_list)) {
    write(paste("SampleName = ", "'", names(pop_list)[i], "'", sep = ""), file = out_file, append = TRUE)
    write(paste("SampleSize = ", nrow(pop_list[[i]][[1]]), sep = ""), file = out_file, append = TRUE)
    write("SampleData={", file = out_file, append = TRUE)
    
    for (j in 1:nrow(pop_list[[i]][[1]])) {
      utils::write.table(t(c(str_sub(rownames(pop_list[[i]][[1]])[j], 1, -3), "\t1\t", pop_list[[i]][[1]][j, ])), file = out_file, 
                         append = TRUE, quote = FALSE, sep = "\t", row.names = FALSE, 
                         col.names = FALSE)
      utils::write.table(t(c("\t\t\t\t", pop_list[[i]][[2]][j, ])), file = out_file, 
                         append = TRUE, quote = FALSE, sep = "\t", row.names = FALSE, 
                         col.names = FALSE)
    }
    write("}", file = out_file, append = TRUE)
    write("", file = out_file, append = TRUE)
  }
  
  write("[[Structure]]", file = out_file, append = TRUE)
  write("StructureName = 'One Group'", file = out_file, append = TRUE)
  write("NbGroups = 1", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write("Group = {",  file = out_file, append = TRUE)
  for (i in 1:length(names(pop_list))) {
    write(paste("\t\t", "\"", names(pop_list)[i], "\"", sep = ""),  file = out_file, append = TRUE)
  }
  write("}",  file = out_file, append = TRUE)
  
  return(invisible(NULL))
}


################################
#' @title df2genepop
#' @description converts df format data to Genepop infile
#' @description modified vcf2genepop function (vcf2others package)
#' @author Tomas Hrbek January 2022
#'
#' @param df -> df object (individuals as rows, two columns per genotype)
#' @param ind_pop -> population assignment of individuals in df (factor)
#' @param keep_pop -> population(s) of interest to include in Genepop infile (fator)
#' @param inc_missing -> include missing data (logical)
#' @param out_file -> name of file to output (Genepop infile)
#' @export Genepop infile of microsatellites
#' @return nothing
#'
#' @details
#' This function converts df object to a Genepop formatted input file
#' This function labels populations. To read labeled populations use "read_genepop" function
#' The function will remove indels, and multiallelic loci, and optionally loci with missing data
#' 01, 02, 03, 04 is 'A', 'C', 'G', 'T'
#'
#' @example
#' df2genepop(df = my_df, ind_pop = ind_pop, keep_pop = keepers, inc_missing = TRUE, out_file = "Genepop_infile.gen")
#' df2genepop(my_df, ind_pop, keepers, out_file = "Genepop_infile.gen")
#' df2genepop(my_df, ind_pop, keepers)
#'

df2genepop <- function (df, ind_pop, keep_pop, inc_missing = TRUE, 
                         out_file = "genepop_infile.txt") {
  if (class(df) != "data.frame") {
    stop(paste("Expecting an object of class data.frame, received a", 
               class(df), "instead"))
  }
  if (class(ind_pop) != "factor" | class(keep_pop) != "factor") {
    stop(paste("Expecting population vector, received a", 
               class(ind_pop), "and", class(keep_pop), "instead"))
  }
  if (inc_missing == FALSE) {
    df <- df[!rowSums(is.na(df)), ]
  }
  df_list <- lapply(keep_pop, function(x) {
    df[x == ind_pop, ]
  })
  names(df_list) <- keep_pop
  pop_list <- vector(mode = "list", length = length(df_list))
  names(pop_list) <- names(df_list)
  
  write("Title = 'Generated by df2genpop.R'", file = out_file)
  suppressWarnings(write.table(df[0,][-1][c(TRUE, FALSE)], file = out_file, quote = FALSE, sep = ", ", col.names = TRUE, append = TRUE))

  for (i in 1:length(df_list)) {
    gt <- df_list[[i]]
    rownames(gt) <- gt[,1]
    gt <- gt[,-1]
    gt[is.na(gt)] <- '000'
    for (j in 1:ncol(gt)) {
      if (j %% 2 != 0) {
        # merge adjacent columns into one
        gt[,j] <- str_c(gt[,j], gt[,j+1])
      }
    }
    gt <- gt[, c(TRUE, FALSE)]
    write(paste("pop ", names(pop_list)[i], sep = ""), file = out_file, append = TRUE)
    write.table(cbind(sep = ',', gt), file = out_file, quote = FALSE, sep = " ", col.names = FALSE, append = TRUE)
  }
  
  return(invisible(NULL))
}
